#' A function to calculate the interval estimate of the surrogate R-squared measure.
#'
#'
#' @param surr_rsq A object of class \code{"surr_rsq"} that is generated by the function \code{"surr_rsq"}.
#' It contains the following components: \code{surr_rsq}, \code{reduced_model}, \code{full_model}, and \code{data}.
#' @param alpha The significance level alpha. The confidence level is 1-alpha.
#' @param B The number of bootstrap replications.
#' @param ... Additional optional arguments.
#'
#' @return An list that contains the CI_lower, CI_upper.
#'
#' @importFrom progress progress_bar
#' @importFrom stats update lm nobs quantile
#' @importFrom scales percent
#'
#' @export
#'
surr_rsq_ci <-
  function(surr_rsq,
           alpha = 0.05,
           B     = 1000,
           ...){
    # Save B+1 surrogate rsq, the first one is calculated from full data.
    B <- B + 1

    # Add progress bar --------------------------------------------------------
    pb <- progress_bar$new(
      format = "Replication = :letter [:bar] :percent :elapsed | eta: :eta",
      total = B,    # 300
      width = 80)
    progress_repNo <- c(1:B)  # token reported in progress bar


    # Estract components from surr_rsq object
    res_s <- surr_rsq[[1]]
    reduced_model <- surr_rsq[[2]]
    full_model <- surr_rsq[[3]]
    data <- surr_rsq[[4]]

    n <- nrow(data)
    # resultTable <- array(NA, dim = c(dim(data),1,B))
    # resultTable[,,1,1] <- res_s
    resultTable <- rep(NA, B)
    resultTable[1] <- res_s[[1]]

    for (j in 2:B) {
      BS_data <- data[sample(1:n, n, replace = T), ]
      try(
        resultTable[j] <- surr_rsq(reduced_model, full_model,data)[[1]]
      )
      while( is.na(resultTable[j])) {
        BS_data <- data[sample(1:n, n, replace = T), ]
        try(
          resultTable[j] <- surr_rsq(reduced_model, full_model, data)[[1]]
        )
      }

      # ProgressBar
      pb $tick(tokens = list(letter = progress_repNo[j]))
    }

    # CI_lower <- apply(X = resultTable[,,,-1], MARGIN = c(1,2,3), FUN = quan_025)
    # CI_lower <- round(CI_lower[1:5,,1], 3)
    CI_lower <- quantile(x = resultTable[-1], probs = c(alpha/2))
    CI_lower <- round(CI_lower, 3)

    # CI_upper <- apply(X = resultTable[,,,-1], MARGIN = c(1,2,3), FUN = quan_975)
    # CI_upper <- round(CI_upper[1:5,,1], 3)

    CI_upper <- quantile(x = resultTable[-1], probs = c(1 - alpha/2))
    CI_upper <- round(CI_upper, 3)

    # CI_lower_avg <- apply(X = resultTable, MARGIN = c(1,2), FUN = mean)
    # CI_lower_avg <- round(CI_lower_avg[1:5,], 3)

    # CI_upper_avg <- apply(X = resultTable, MARGIN = c(1,2), FUN = mean)
    # CI_upper_avg <- round(CI_upper_avg[1:5,], 3)

    # return_list <- list("CI_lower"     = CI_lower,
    #                     "CI_upper"     = CI_upper
    #                     # ,
    #                     # "CI_lower_avg" = CI_lower_avg,
    #                     # "CI_upper_avg" = CI_upper_avg
    #                     )


    return_list <- data.frame(Lower = c(percent(alpha/2, 0.01), CI_lower),
                              Upper = c(percent(1 - alpha/2, 0.01), CI_upper),
                              row.names = c("Percentile", "Confidence Interval")
                        # ,
                        # "CI_lower_avg" = CI_lower_avg,
                        # "CI_upper_avg" = CI_upper_avg
    )


    return(return_list)
  }
